#include <iostream>
#include <vector>
//COMO O ARQUIVO .h ESTÁ NO MESMO DIRETORIO QUE MEU ARQUIVO EM QUE VOU IMPORTÁ-LO UTILIZAMOS "", SE FOSSE EM OUTRO DIRETÓRIO USARIAMOS O <>
//BASICAMENTE ESTAMOS MANTENDO O "GROSSO" DO CODIGO E FUNÇÕES NUM ARQUIVO .h E IMPORTAMOS ELE PRO CODIGO PRINCIPAL ONDE USAREMOS AS FUNCOES E DEFINICOES IMPLEMENTADAS NELE
#include "utilidades.h"

    int main()
{
    //NÃO PRECISA COLOCAR O TIPO, MAS É BOM 
    printMensagem<int>(1);
    printMensagem<std::string>("Hello");
    printMensagem(3.14);
    printMensagem(true);

    std::cout << soma(1.5,2,435314,13213,1321,23,0.223) << std::endl;
    std::cout << soma(std::string {"Arthur"}, std::string{"de Lima"}, std::string{"Sobreira"}) << std::endl;


    //PARA ACESSAR ENDEREÇOS DE MEMORUA UTILIZAR O &
    int x = 5;
    int& referenciaX = x; //REFERENCIAX É UM APELIDO PARA X, QUALQUER MODIFICAÇÃO EM REFERENCIAX MODIFICARÁ X
    std::cout << "x: " << x << " referenciaX: " << referenciaX << std::endl;
    int* ponteiroX = &x; //PONTEIROX É UM PONTEIRO PARA O ENDEREÇO DE X, UTILIZAMOS O * PARA DECLARAR UM PONTEIRO E O & PARA PEGAR O ENDEREÇO DE UMA VARIÁVEL
    void* ponteiroX2 = &x; //PONTEIROX2 É UM PONTEIRO GENERICO, ELE APONTA PARA UM ENDEREÇO DE MEMÓRIA MAS NÃO SABE O TIPO DE DADO QUE ESTÁ LÁ, PORTANTO NÃO PODE SER DESREFERENCIADO
    // ponteiroX = 9; ESSA OPERAÇÃO DARIA ERRO POIS ESTAMOS TENTANDO ATRIBUIR UM VALOR INTEIRO PARA UM PONTEIRO
    std::cout << *(int*)ponteiroX2 << std::endl; //AQUI ESTAMOS DESREFERENCIANDO O PONTEIRO GENERICO, MAS PARA ISSO PRECISAMOS DIZER PARA O COMPILADOR QUE TIPO DE DADO TEM LÁ, NO CASO UM INTEIRO
    std::cout << *static_cast<int*>(ponteiroX2); //ESSE DAQUI GARANTE QUE O PONTEIRO É REALMENTE DAQUELE TIPO
    *ponteiroX = 10; //AGORA MODIFICANDO O VALOR DO ENDEREÇO QUE PONTEIROX APONTA, MODIFICAMOS O VALOR DE X
    int* heapX = new int {5}; //UMA VARIAVEL INTEIRA COM VALOR 5 É CRIADA NA HEAP E O ENDEREÇO DELA É ARMAZENADO NA STACK COM A VARIALVEL heapX, QUE É UM PONTEIRO
    //A HEAP DEVE SER USADA QUANDO É NECESSARIO UM ARMAZENAMENTO DE DADOS MAIOR
    //A HEAP NÃO É REMOVIDA AUTOMATICAMENTE QUE NEM A STACK, ELA SO SERA REMOVIDA AO FIM DO RUNTIME DO PROGRAMA
    //PARA REMOVER MANUALMENE BASTA UTILIZAR delete nome;
    int* outroPonteitoX = heapX;
    delete heapX; 
    heapX = nullptr; //APOS DELETAR O VALOR DA HEAP, A VARIAVEL CONTINUA NA STACK, PARA TIRAR O APONTAMENTO DELA DA EAP, COLOCAMOS nullptr
 
    if (outroPonteitoX != nullptr)
    {
        std::cout << outroPonteitoX;
        //ISSO VAI RETORNAR UM VALOR NADA A VER, POIS DELETAMOS O VALOR QUE ELA REFERENCIAVA E ESQUECEMOS DE ALTERAR PARA nullptr, O PROBLEMA É QUE DIFERENTEMENTE DO heapX QUE CASO ACESSAMOS APOS DELETAR DARIA ERRO, ESSE NAO DA ERRO E CONSIDERA TRUE
    }
}