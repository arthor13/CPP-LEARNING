#include <iostream>

/*
VAMOS SUPOR QUE TENHAMOS UMA FUNÇÕ QUE PODE VIR A LIDAR COM DIFERENTES TIPOS DE DADOS, AO INVÉS DE CRIARMOS DIFERENTES FUNÇÕES COM DIFERENTES ARGUMENTOS PODEMOS UTILIZAR TEMPLATES PARA TRIVIALIZAR O PROCESSO
NO MEU EXEMPLO ESTOU UTILIZANDO O TEMPLATE PARA UMA FUNCAO printMensagem() QUE IRÁ IMPRIMIR QUALQUER DADO INDEPENDENTE DO TIPO DE DADO QUE FOR COLOCADO NO ARGUMENTO DA FUNÇÃO
BASICAMENTE O QUE ELE ESTÁ FAZENDO É:
    A FUNÇÃO DE printMensagem NÃO EXISTE NO MEU CODIGO, ELA PASSA A EXISTIR QUNADO EU CHAMO ELA E COLOCO DADO QUE EU QUERO, NESSE MOMENTO O TEMPLATE IRÁ COPIAR O CÓDIGO DA FUNÇÃO, 
    PORÉM AO INVÉS DO TIPO DE DADO SER DO TEMPLATE, ELE SERÁ DO TIPO DE DADO INPUTADO NO ARGUMENTO DA FUNÇÃ CHAMADA
    NO CASO DO MEU CÓDIGO AQUI QUANDO EU CHAMO 
        printMensagem(1); ELE IRÁ CRIAR UMA COPIA A FUNÇÃO ONDE O ARGUMENTO É INTEIRO
        printMensagem("Hello"); ELE IRÁ CRIAR UMA COPIA A FUNÇÃO ONDE O ARGUMENOT É STRING
    NÃO É NECESARIO NESSE CASO PORÉM É SEMPRE BOM COLOAR O TIPO DE DADO QUE O TEMPLATE VAI TER ANTES DO ARGUMENTO
        printMensagem<int>(1);
*/
template<typename M>
void printMensagem(M msg)
{
    std::cout << msg << ' ';
}



/*
BASICAMENTE É POSSIVEL FAZER UMA FUNÇÃO COM NUMERO DE PARAMETROS VARIAVEIS
NO MEU EXEMPLO CRIAMOS UM TEMPLATE QUE POSSUI DOIS TYPENAMES, O ULTIMO TENDO ...
BASICAMENTE É COMO SE ELE RECEBESSE UMA LISTA DE PARAMETROS QUE ENTAO SAO LIDADOS
RECURSIVAMENTE NA MINHA FUNÇÃO DE SOMA
POREM AO CHEGAR NA ULTIMA ITERACAO DA MINHA SOMA ELE DARIA ERRO, POIS NA MENTE DELE O SEGUNDO PARAMETRO DEVERIA TER MAIS DE UM PARAMETRO
PARA ISSO CRIAMOS UMA OUTRA FUNCAO DO MESMO TEMPLATE QUE POSSUI SOMENTE UM ARGUMENTO
ENTAO QUAND CEHGAR NA ULTIMA ITERACAO DA MINHA RECURSÃO A SOMA DARÁ CERTO

E LEMBRANDO É POSSIVEL UTILIZAR ISSO PARA TODOS OS TIPOS DE DADOS, LEMBRANDO QUE É SEMPRE BOM 
UTILIZAR O <> COM O TIPO DO TEMPLATE, POIS NESSES CASOS MAIS COMPLEXOS PROVAVELMENTE PODE DAR ERRO
*/
template<typename T>
T soma(T t)
    {
        return t;
    }
//É POSSIVEL FAZER UMA FUNÇÃO COM NUMERO DE ARGUMENTS VARIADOS UTILIZANDO TEMPLATES
template<typename PrimeiroArgumento, typename... Outros>
PrimeiroArgumento soma (PrimeiroArgumento primeiroArgumento, Outros... outros)
    {
        return primeiroArgumento + soma(outros...);
    }

//É POSSIVEL ESPEIALIZAR O TIPO DO SEU TEMPLATE, BASICAMENTE ESPECIFICANDO UM DOS TIPOS
//FAZENDO COM QUE ELES SE COMPORTEM DIFERENTEMENTE DEPENDENDO DA SITUAÇÃO
std::string soma(std::string t)
    {
        return t;
    }
//É POSSIVEL FAZER UMA FUNÇÃO COM NUMERO DE ARGUMENTS VARIADOS UTILIZANDO TEMPLATES
template< typename... Outros>
//PERCEBA COMO AGORA EU POSSO ADICIONAR STRINGS COM ESPAÇOS ENTRE ELAS SEM MODIFICAR A FUNCIONALDIADE DO MEU TEMPLATE DE SOMAS ANTERIORS
std::string soma (std::string primeiroArgumento, Outros... outros)
    {
        return primeiroArgumento + " " + soma(outros...);
    }


//UTILIZAR COM CUIDADO POIS ISSO PODE ACABAR DANDO MUITOS PROBLEMAS, E O TEMPLATE EM SI É BEM DIFICL DE ENTENDER E PRECISA SER BEM DOCUMENTADO

